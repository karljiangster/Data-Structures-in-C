/* returns a pseudo-boolean int representing true if and only if all
* elements of the array a with length alen are positive. 
*/ 
int all_positive(int a[], unsigned int alen);

/* returns a pseudo-boolean int representing true if and only if all 
* elements of the array a with length alen are positive.
*/ 
int exists_positive(int a[], unsigned int alen);

/* returns the index of the first (i.e., with the smallest index) 
* element in the array that is positive. If no element is positive, 
*return -1.
*/ 
int first_positive(int a[], unsigned int alen);

/* returns the number of positive numbers in the array. */ 
unsigned int number_positives(int a[], unsigned int alen);

/* changes the sign of every element in the array */ 
void negate(int a[], unsigned int alen);

/* returns a new array containing partial sums over the provided array */
int* partial_sums(int a[], unsigned int alen);

/* modifies the passed-in array such that each value appears, 
* in the updated array, one more spot to the "right" than before 
*/ 
void rotate_right(int a[], int alen);


//PROBLEM 2 

/* Given int n, updates aray factors [] that contains the factors of n in 
*increasing order of index. Updates flen as well, the number of factors.
* Note that if flen is not large enough, an error will occur. 
*/  
void factorization(unsigned int n, unsigned int factors[], 
unsigned int* flen);

//PROBLEM 3 

/* Takes in an array of code numbers and its length and returns
* a string with the decoded message.
*/ 
char* decode(unsigned int a[], unsigned int alen);






