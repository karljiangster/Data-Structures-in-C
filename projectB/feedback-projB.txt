;; Project A Guideline

;; _total-score_                    	104 / 104

;; ====== correctness

;; The reason for visual inspection is so that
;; not everything needs to be exact. Please give
;; partial credit when appropriate, and don't require
;; everything to look *exactly* like the reference
;; picture. Also, don't judge the ambient light on anything
;; except the picture that is looking at ambient light. In 
;; that picture, the student's picture is compared to its own
;; picture, not a reference. You just need to make sure that 
;; the second picture is darker than the first picture due to
;; lower ambient light.


## Color is somehow messed up: check your code
;; === making textures ===
;; vertical striped texture		8 / 8
-3 if it has stripes but wrong number of them
;; horizontal striped texture		8 / 8
-3 if it has stripes but wrong number of them
;; waves texture			8 / 8


;; === texture mapping  ===
;; poster texture mapping		8 / 8
;; sphere texture mapping		8 / 8

;; === lighting ===
;; sphere is brighter on one side than the other 8 / 8
;; sphere casts a shadow on the poster  8 / 8
;; handles light position change 8 / 8
;; poster casts shadow on large sphere 3 / 3
;; lower ambient light darkens picture 3 / 3

;; === correctness subtotal ===		70 / 70

;; === style ===

;; development process		     15 / 15
-4 - compiled properly with their own files
-4 - functions are complete and in the appropriate files
-4 - used subversion correctly		
-15 - required editing their code (to do more than problems above)
(take off no more than 10)

;; adequate tests                   5  / 5
(no helper function tests necessary)
(tests should be modularized)

;; well-written purposes             2 / 2
;; proper indentation, line breaks   2 / 2
;; well-named variables		     2 / 2

;; === efficiency ===
;; make sure to grade their test code for efficiency, as well
;; well-chosen control structures   4  / 4
(no blatant inefficiencies or confusing control)
;; chose relatively small texture maps in horiz_stripes, vert_stripes / 4
(based on number of stripes)

;; _style_subtotal			34 / 34

;; === partial credit ===
;; They only earn points here for places where
;;  they earned 0 for correctness tests

;; horizontal stripes			/ 2
;; vertical stripes			/ 2
;; make_waves				/ 2
;; map_texture_on_poster 		/ 2
;; map_texture_on_sphere 		/ 2

;; wrote code to detect intersections for shadowing / 2
;; wrote code to modulate light based on shadow hit / 2

;; partial_credit _subtotal_:	 	

;; graded by GRADER'S_NAME_HERE

#include "raytracer.h"

/*
typedef struct {
  location loc;
  unsigned int h;
  unsigned int w;
} camera;
*/

/* ===================================== */ 
/* === camera operations => camera.c === */ 
/* ===================================== */ 

const char *_cam_fmt = "camera(loc:%s,h:%u,w:%u)";

char *camera_tos(camera cm)
{
  char buf[128];
  memset(buf,0,128);
  char *loc = xyz_tos(cm.loc);
  snprintf(buf,128,_cam_fmt,loc,cm.h,cm.w);
  free(loc);
  return strdup(buf);
}

void camera_show(FILE *f, camera cm)
{
  char *s = camera_tos(cm);
  fprintf(f,"%s",s);
  free(s);
}
#include <string.h>
#include "raytracer.h"

/* =================================== */ 
/* === color operations => color.c === */ 
/* =================================== */ 

void _color_expr_check(char c, double x)
{
  if (x<0||x>1) {
    fprintf(stderr,"error (color_expr): %c out of range: %lf\n",c,x);
    exit(1);
  }
}

/* reject if any component is outside [0.0,1.0] */
color color_expr(double r, double g, double b)
{
  _color_expr_check('r',r);
  _color_expr_check('g',g);
  _color_expr_check('b',b);
  color c = {r,g,b};
  return c;
}

/* color_modulate : multiply the components of two colors */
/* (r,g,b) * (R,G,B) = (rR,gG,bB) */
color color_modulate(color c1, color c2)
{
  return color_expr(c1.r*c2.r,c1.g*c2.g,c1.b*c2.b);
}

/* _clamp : restrict x to [0,1] by clipping */
double _clamp(double x)
{
  return x<0?0:(x>1?1:x);
}

/* color_scale : scale each component by given scalar, but */
/* don't allow any component in the result to fall outside [0,1] */
color color_scale(double s, color c)
{
  return color_expr(_clamp(s*c.r),_clamp(s*c.g),_clamp(s*c.b));
}

/* add components of colors, but */
/* don't allow any component in the result to exceed 1 */
color color_add(color c1, color c2)
{
  return color_expr(_clamp(c1.r+c2.r),_clamp(c1.g+c2.g),_clamp(c1.b+c2.b));
}

const char *_color_fmt = "color(%lf,%lf,%lf)";

char *color_tos(color c)
{
  char buf[128];
  memset(buf,0,128);
  snprintf(buf,128,_color_fmt,c.r,c.g,c.b);
  return strdup(buf);
}

void color_show(FILE *f, color c)
{
  fprintf(f,_color_fmt,c.r,c.g,c.b);
}

unsigned char _byte(double x)
{
  return (unsigned char)(x*255.0);
}

/* color_show_bytes */
/* print three integers on [0,255] with spaces in between and a newline */
/* suitable for use in a PPM */
void color_show_bytes(FILE *f, color c)
{
  fprintf(f,"%u %u %u\n",_byte(c.r),_byte(c.g),_byte(c.b));
}

#include "raytracer.h"

/*
typedef struct {
  enum {MISS=0,HIT=1} miss;
  double t;
  location hit_point;
  color surf; // not used in project A
  color shine; // not used in project A
  direction surf_norm; // not used in project A
} hit_test;
*/

/* ========================================= */ 
/* === hit_test operations => hit_test.c === */ 
/* ========================================= */ 

const char *_hit_test_fmt = 
  "hit_test(\n  t:%lf\n  hit_point:%s\n  surf:%s\n  shine:%s\n  surf_norm:%s\n)";

char *hit_test_tos(hit_test t)
{
  if (t.miss==MISS)
    return strdup("MISS");
  char buf[1024];
  memset(buf,0,1024);
  char *shp = xyz_tos(t.hit_point);
  char *srf = color_tos(t.surf);
  char *shn = color_tos(t.shine);
  char *nrm = xyz_tos(t.surf_norm);
  snprintf(buf,1024,_hit_test_fmt,t.t,shp,srf,shn,nrm);
  free(shp);
  free(srf);
  free(shn);
  free(nrm);  
  return strdup(buf);
}

void hit_test_show(FILE *f, hit_test t)
{
  char *s = hit_test_tos(t);
  fprintf(f,"%s",s);
  free(s);
}
#include <math.h>
#include "raytracer.h"

/* === intersect.c === */

/* to fill in slots not used in project A */
color _c0 = {0,0,0};
xyz _v0 = {0,0,0}; 

hit_test sph_int(ray r, object obj, sphere s)
{
  xyz A = xyz_sub(r.origin,s.center);
  double B = xyz_dot(A,r.dir);
  double C = xyz_dot(A,A)-s.radius*s.radius;
  double D = B*B-C;
  double t = (-B)-sqrt(D);
  if (D>0&&t>0) {
    location pos = ray_position(r, t); 
    direction surf_dir = xyz_sub(pos, s.center);
    color surf = s.surface_color(&obj, pos); 
    hit_test ht = {HIT, t, pos, surf,_c0, xyz_norm(surf_dir) };
    return ht;
  } else {
    // if it doesn't hit, then it's a miss, and nothing else in the struct matters
    hit_test ht = {MISS,0,_v0,_c0,_c0,_v0};
    return ht;
  }
}

/* pre: the location's z matches the poster's */
/* (this is an outcome of the math given)     */
int on_poster(poster *p, location loc)
{
  return (loc.x>=p->upper_left.x) &&
         (loc.x<=(p->upper_left.x+p->w)) &&
         (loc.y<=p->upper_left.y) &&
         (loc.y>=(p->upper_left.y-p->h));
}

hit_test pst_int(ray r, object obj, poster p)
{
  xyz n = xyz_expr(0,0,-1);
  double d = p.upper_left.z;
  double t = -(xyz_dot(r.origin,n)+d)/xyz_dot(r.dir,n);
  location hp = ray_position(r,t);
  if (t>0&&on_poster(&p,hp)) {
    color surf = p.surface_color(&obj, hp); 
    hit_test ht = {HIT, t, hp, surf, {0,0,0}, n};
    return ht;
  } 
  hit_test ht = {MISS,0,{0,0,0},{0,0,0},{0,0,0},{0,0,0}};
  return ht;
}

hit_test intersect(ray r, object obj)
{
  switch (obj.tag) {
  case SPHERE:
    return sph_int(r, obj, obj.o.s); 
  case POSTER:
    return pst_int(r, obj, obj.o.p);
  default:
    fprintf(stderr,"error (intersect): unknown object tag %d\n",obj.tag);
    exit(1);
  }
}
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

/* ===================================== */ 
/* === light operations => light.c === */ 
/* ===================================== */ 


const char *_light_fmt = "light(\n direction: %s\n color:%s\n)"; 

char *light_tos(light l) { 

    char buf [50]; 
    sprintf(buf, _light_fmt, xyz_tos(l.dir), color_tos(l.c) ); 
    return strdup(buf); 
} 


void light_show(FILE *f, light l) {

   fprintf(f, "%s", light_tos(l) );  

} 


#include <string.h>
#include "raytracer.h"

/* ======================================*/ 
/* === object list ops => obj_list.c === */ 
/* ======================================*/ 

obj_list *ol_cons(object o, obj_list *os)
{
  obj_list *new_list = (obj_list*)malloc(sizeof(obj_list));
  if (new_list==NULL) {
    fprintf(stderr,"error (ol_cons): malloc failed\n");
    exit(1);
  }
  new_list->obj = o;
  new_list->next = os;
  return new_list;
}

obj_list *ol_singleton(object s)
{
  return ol_cons(s,NULL);
}

/* helper function to concatenate three strings */
char *_cat3(char *s1, char *s2, char *s3)
{
  int i;
  unsigned int len1 = strlen(s1);
  unsigned int len2 = strlen(s2);
  unsigned int len3 = strlen(s3);
  char *s4 = (char*)malloc(len1+len2+len3+1);
  for (i=0; i<len1; i++)
    s4[i] = s1[i];
  for (i=0; i<len2; i++)
    s4[len1+i] = s2[i];
  for (i=0; i<len3; i++)
    s4[len1+len2+i] = s3[i];
  s4[len1+len2+len3]='\0';
  return s4;
}

char *ol_tos(obj_list *os)
{
  char *s = strdup("obj_list[");
  char *t = strdup("");
  while (os) {
    char *o = object_tos(os->obj);
    t = s;
    s = _cat3(s,o,os->next?":":"");
    os=os->next;
    free(o);
    free(t);
  }
  t = s;
  s = _cat3(s,"]","");
  free(t);
  return s;
}

void ol_show(FILE *f, obj_list *os)
{
  char *s = ol_tos(os);
  fprintf(f,"%s",s);
  free(s);
}

void ol_free(obj_list *ss)
{
  if (ss) {
    ol_free(ss->next);
    free(ss);
  }
}
#include "raytracer.h"

/* ===================================== */ 
/* === object operations => object.c === */ 
/* ===================================== */ 

char *object_tos(object o)
{
  char buf[1024];
  memset(buf,0,1024);
  char *s;
  switch (o.tag) {
  case SPHERE:
    s = sphere_tos(o.o.s);
    break;
  case POSTER:
    s = poster_tos(o.o.p);
    break;
  default:
    fprintf(stderr,"error (object_tos): unexpected tag in object %d",o.tag);
    exit(1);
  }
  snprintf(buf,1024,"object[\n%s,\n  texture:%p\n]",s,o.t);
  free(s);
  return strdup(buf);    
}

void object_show(FILE *f, object o)
{
  char *s = object_tos(o);
  fprintf(f,"%s",s);
  free(s);
}
#include "raytracer.h"

/* ======================================= */ 
/* === poster operations => poster.c ===== */ 
/* ======================================= */ 

/* poster_expr : construct a poster record,
 * setting object pointer to NULL (unused in this implementation)
 * and texture to NULL (future expansion)
 */
poster poster_expr(location ulc, 
		   double w, 
		   double h, 
		   color(*sc)(object*,location), 
		   color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (poster_expr): malloc failed\n");
    exit(1);
  }
  if (w<0) {
    fprintf(stderr,"error (poster_expr): negative w: %lf\n",w);
    exit(1);
  }
  if (h<0) {
    fprintf(stderr,"error (poster_expr): negative h: %lf\n",w);
    exit(1);
  }
  new_obj->tag = POSTER;
  new_obj->o.p.upper_left = ulc;
  new_obj->o.p.w = w;
  new_obj->o.p.h = h;
  new_obj->o.p.surface_color = sc;
  new_obj->o.p.shine = sh;
  new_obj->o.p.o = NULL;
  new_obj->t = NULL; // texture reserved for project B
    
  return new_obj->o.p;
}

const char *_pst_fmt =
  "poster(\n  upper_left:%s\n  w:%lf\n  h:%lf\n  surface_color:<FN@%p>\n  shine:%s\n  object:%p\n)";

char *poster_tos(poster s)
{
  char buf[1024];
  memset(buf,0,1024);
  char *ulc = xyz_tos(s.upper_left);
  char *shn = color_tos(s.shine);
  snprintf(buf,1024,_pst_fmt,ulc,s.w,s.h,s.surface_color,shn,s.o);
  free(ulc);
  free(shn);
  return strdup(buf);
}

void poster_show(FILE *f, poster s)
{
  char *t = poster_tos(s);
  fprintf(f,"%s",t);
  free(t);
}
#include "raytracer.h"

/* =============================== */ 
/* === ray operations => ray.c === */ 
/* =============================== */ 

/* see web page for ray_position code */
xyz ray_position(ray r, double t)
{
  return xyz_add(r.origin, xyz_scale(t, r.dir));
}

const char *_ray_fmt = "ray(origin:%s,dir:%s)";

char *ray_tos(ray r)
{
  char buf[256];
  memset(buf,0,256);
  char *ost = xyz_tos(r.origin);
  char *dst = xyz_tos(r.dir);
  snprintf(buf,256,_ray_fmt,ost,dst);
  free(ost);
  free(dst);
  return strdup(buf);
}

void ray_show(FILE *f, ray r)
{
  char *s = ray_tos(r);
  fprintf(f,"%s",s);
  free(s);
}


#include "raytracer.h"

/* === raytracer.c === */

/* hit test utilities */

const hit_test _miss = {MISS,0,{0,0,0},{0,0,0},{0,0,0},{0,0,0}};

int hit(hit_test t)
{
  return t.miss==HIT;
}

int miss(hit_test t)
{
  return t.miss==MISS;
}

/* coordinate system transformation */

location logical_loc(camera c, unsigned int x, unsigned int y)
{
  double pixw, pixh;
  double lx, ly;
  if (c.h>c.w)
    pixh = pixw = 2.0 / c.h;
  else
    pixh = pixw = 2.0 / c.w;
  if (x>c.w || y>c.h) {
    fprintf(stderr, "error (logical_loc): out of bounds (%d, %d)\n", x, y);
    exit(1);
  }
  lx = -1.0 + (pixw * x) + (pixw / 2.0);
  ly =  1.0 - ((pixh * y) + (pixh / 2.0));
  if (c.w>c.h)
    ly -= (c.w-c.h) / 2.0 * pixh;
  else
    lx += (c.h-c.w) / 2.0 * pixw;
  location result = {lx, ly, 0};
  return result;
}

/* ray tracing */

color color_at(object *obj, location loc)
{
  color(*sc)(object*,location) = 
    obj->tag==SPHERE?
    obj->o.s.surface_color: 
    obj->o.p.surface_color;
  return (*sc)(obj,loc);
}

color trace_ray(scene s, ray r)
{
  obj_list *objs = s.objects;
  hit_test closest_hit = _miss;
  object *closest_obj = NULL;
  /* walk over object list, keep track of closest object if there is one */
  while (objs) {
    /* for each object, check for intersect */
    hit_test curr_hit = intersect(r,objs->obj);
    /* if it hits AND it's the first hit OR it's closer than closest hit */
    if (hit(curr_hit) && (miss(closest_hit) || (curr_hit.t<closest_hit.t))) {
      // update this to be the closest hit
      closest_hit = curr_hit;
      closest_obj = &(objs->obj);
    }
    // advance to next object
    objs = objs->next;
  }
  /* if there is a closest object, return its color, otherwise s.bg */
    return closest_obj?lighting(s, r, closest_hit):s.bg;  	

    return closest_obj?color_at(closest_obj,closest_hit.hit_point):s.bg;
}

/* main loop and ppm creation */

void ppm_header(FILE *f, int height, int width)
{
  fprintf(f,"P3\n");
  fprintf(f,"%d %d\n", width, height);
  fprintf(f,"255\n");
}

void render(FILE *f, stage g)
{
  int row, col;
  camera c = g.c;
  scene sc = g.s;
  ppm_header(f,c.h,c.w);
  /* loop over all locations in the pixel field */
  for(row=0; row<c.h; row++) {
    for(col=0; col<c.w; col++) {
      /* 1: Translate from physical to logical */
      location loc = logical_loc(c,col,row);
      /* 2: Create a directional vector from camera to pixel */
      direction dir = xyz_sub(loc,c.loc);
      /* 3: Normalize this vector */
      direction normdir = xyz_norm(dir);
      /* 4: Create a ray starting at the camera in the direction of normdir */
      ray r = {c.loc,normdir};
      /* 5: trace the ray through the scene and obtain the color */
      color col = trace_ray(sc,r);
      /* 6: print that pixel to the screen (which can be redirected to a file) */
      color_show_bytes(f,col);
    }
  }
}


/* Given an intersection location p, light source, and object list,
 * check each object to see if it intersects the shadow ray. 
 * return nonzero if the location p is in shadow. Return 0 if not.
 */
int shadow(location p, light l, obj_list *objs) { 

    direction nudge = xyz_scale(1e-6, l.dir); 

    ray light_ray = { xyz_add(p, nudge), l.dir }; 

    obj_list* tmp = objs;
    while ( tmp != NULL && intersect(light_ray, tmp -> obj).miss != HIT )
	tmp = tmp -> next;
    //return 0;
    return tmp != NULL; 

}  


/* Given a scene, ray, and hit_test, determine the color of the pixel.
 * The hit_test already calculated the surface color of the shape in the 
 * absence of lighting. Here, you take into account shadow and ambient
 * light to adjust the color. */
color lighting(scene s, ray r, hit_test h) { 

    color surf = h.surf; //already computed color in intersect 
    if(h.miss == MISS) 
	return s.bg; 
    if( shadow(h.hit_point, s.light, s.objects) ) { 
	return color_modulate(surf, s.bg); 	
    } 
    else { 
	double beyond = xyz_dot(h.surf_norm, s.light.dir); 
	color diffuse = color_scale( (beyond > 0) ? beyond : 0,
	       	s.light.c); 
	return color_modulate(surf, color_add(s.bg, diffuse) ); 		
    } 
} 



#include "raytracer.h"

int main(int argc, char *argv[])
{
  unsigned sel = argc>1 ? atoi(argv[1]) : 0;
  stage stg = get_stage(sel);
  
  FILE *f = fopen("evidence.ppm", "w"); 

  render(f,stg);

  printf("Object has been created...\n"); 

  ol_free(stg.s.objects);

  return 0;
}

#include "raytracer.h"

/*
typedef struct {
  color bg;
  obj_list *objects;
  light light; // not used in project A
  color amb; // not used in project A
} scene;
*/

/* =================================== */ 
/* === scene operations => scene.c === */ 
/* =================================== */ 

const char *_scene_fmt = 
  "--- begin scene\nbg:    %s\nlight: (unused)\namb:   (unused)\n"
  "objs:  %s\n--- end scene\n";

char *scene_tos(scene sc)
{
  char buf[1024];
  memset(buf,0,1024);
  char *bgs  = color_tos(sc.bg);
  char *os   = ol_tos(sc.objects);
  snprintf(buf,1024,_scene_fmt,bgs,os);
  char *result = strdup(buf);
  free(bgs);
  free(os);
  return result;
}

void scene_show(FILE *f, scene sc)
{
  char *s = scene_tos(sc);
  fprintf(f,"%s",s);
  free(s);
}
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

/* ===================================== */ 
/* === sphere operations => sphere.c === */ 
/* ===================================== */ 

/* sphere_expr : construct a sphere record,
 * setting object pointer to NULL (unused in this implementation)
 * and texture to NULL (future expansion)
 */
sphere sphere_expr(location v, 
		   double r, 
		   color(*sc)(object *,location), 
		   color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (sphere_expr): malloc failed\n");
    exit(1);
  }
  new_obj->tag = SPHERE;
  new_obj->o.s.center = v;
  new_obj->o.s.radius = r;
  new_obj->o.s.surface_color = sc;
  new_obj->o.s.shine = sh;
  new_obj->o.s.o = NULL;
  new_obj->t = NULL; // texture reserved for project B
  return new_obj->o.s;
}

const char *_sph_fmt =
  "sphere(\n  center:%s\n  radius:%lf\n  surface_color:<FN@%p>\n"
   "  shine:%s\n  object:%p\n)";

char *sphere_tos(sphere s)
{
  char buf[1024];
  memset(buf,0,1024);
  char *ctr = xyz_tos(s.center);
  char *shn = color_tos(s.shine);
  snprintf(buf,1024,_sph_fmt,ctr,s.radius,s.surface_color,shn,s.o);
  free(ctr);
  free(shn);
  return strdup(buf);
}

void sphere_show(FILE *f, sphere s)
{
  char *t = sphere_tos(s);
  fprintf(f,"%s",t);
  free(t);
}
#include "raytracer.h"

/* =================================== */ 
/* === stage operations => stage.c === */ 
/* =================================== */ 

const char *_stage_fmt = "*** begin stage\n\n%s\n\n%s\n*** end stage\n";

char *stage_tos(stage stg)
{
  char buf[1024];
  memset(buf,0,1024);
  char *c = camera_tos(stg.c);
  char *s = scene_tos(stg.s);
  snprintf(buf,1024,_stage_fmt,c,s);
  free(c);
  free(s);
  return strdup(buf);
}

void stage_show(FILE *f, stage stg)
{
  char *s = stage_tos(stg);
  fprintf(f,"%s",s);
  free(s);
}

/* constant coloring functions for easy testing */

color sc_red(object *o, location loc)
{
  return color_expr(1,0,0);
}

color sc_green(object *o, location loc)
{
  return color_expr(0,1,0);
}

/* sc_blue : surface color function that returns blue, always */
color sc_blue(object *o, location loc)
{
  return color_expr(0,0,1);
}

/* sc_maroon : surface color function that returns maroon, always */
color sc_maroon(object *o, location loc)
{
  return color_expr(0.5,0,0);
}

color sc_purple(object *o, location loc)
{
  return color_expr(0.5,0,0.5);
}

color sc_gray(object *o, location loc)
{
  return color_expr(0.5,0.5,0.5);
}

/* object constructors */

object *sphere_obj(location v, double r, color(*sc)(object*,location), color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (sphere_obj): malloc failed\n");
    exit(1);
  }
  new_obj->tag = SPHERE;
  new_obj->o.s.center = v;
  new_obj->o.s.radius = r;
  new_obj->o.s.surface_color = sc;
  new_obj->o.s.shine = sh;
  new_obj->o.s.o = NULL;
  new_obj->t = NULL;
  return new_obj;
}

object *poster_obj(location ulc, 
		   double w,
		   double h, 
		   color(*sc)(object*,location), 
		   color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (poster_obj): malloc failed\n");
    exit(1);
  }
  new_obj->tag = POSTER;
  new_obj->o.p.upper_left = ulc;
  new_obj->o.p.w = w;
  new_obj->o.p.h = h;
  new_obj->o.p.surface_color = sc;
  new_obj->o.p.shine = sh;
  new_obj->o.s.o = NULL;
  new_obj->t = NULL;
  return new_obj;
}

/* The function get_stage just needs to return a valid stage. */
/* The argument may be used, or not, at your discretion. */
stage get_stage(unsigned int selection)
{
  if (selection==1) {
    /* gallery image foo5.ppm */
    camera cam = {{0,0,-5},1280,1280};
    location ulc = {-1, 4, 1.5};
    object *pst = poster_obj(ulc, 0.5, 6, 
			map_texture_on_poster,color_expr(0,0,0) );
    pst -> t = make_vert_stripes(color_expr(0.5, 0.5, 0.8), 
			color_expr(0.9, 0, 0), 7); 
    light l = { xyz_expr(-0.58, 0.58, -0.58), color_expr(1, 1, 1) }; 
    scene scn = {{0,0,0.25},ol_singleton(*pst), l, color_expr(0.1, 0.1, 0.1) };
    /* valgrind caught this -- it's because the poster is copied into
     * the object list, as opposed to its pointer being copied
     */
    free(pst);
    stage stg = {cam,scn};
    return stg;
  }
  if (selection==2) {
    /* gallery image foo6.ppm */
    camera cam = {{0,0,-5},1280,1280};
    location ulc = {-1.5,1.5,4.5};
	object *pst = poster_obj(ulc, 3, 3, map_texture_on_poster, 
			color_expr(0,0,0));
	pst -> t = make_horiz_stripes(color_expr(0.5, 0.5, 0.8),
		   	color_expr(0.9, 0, 0), 5); 
	light l = { xyz_expr(-0.58, 0.58, -0.58), color_expr(1, 1, 1) }; 
	scene scn = {{0,0,0.25},ol_singleton(*pst), l,
	   	color_expr(0.1, 0.1, 0.1) };
    free(pst);
    stage stg = {cam,scn};
    return stg;
  }
  if (selection==3) {
	/* foo7.ppm */ 
    camera cam = {{0,0,-5},1280,1280};
    location ulc = {-1.5,1.5,4.5};
	object *pst = poster_obj(ulc, 3, 3, map_texture_on_poster, 
			color_expr(0,0,0));
	pst -> t = make_waves(100, 0, 0, color_expr(1, 0, 0));  
	light l = { xyz_expr(-0.58, 0.58, -0.58), color_expr(1, 1, 1) }; 
	scene scn = {{0,0,0.25},ol_singleton(*pst), l,
	   	color_expr(0.1, 0.1, 0.1) };
    free(pst);
    stage stg = {cam,scn};
    return stg;

  }
  if (selection==4) {
    /* gallery image foo9.ppm */
    camera cam = {{0,0,-5},1280,1280};
    location ulc = {-1,4,1.5};
	object *pst = poster_obj(ulc, 0.5, 6, map_texture_on_poster, 
			color_expr(0,0,0));
	texture *stripes = make_vert_stripes(color_expr(0.5, 0.5, 0.8), 
			color_expr(0.9, 0, 0), 7); 
	pst -> t = stripes; 
	object *sphere = sphere_obj(xyz_expr(0, 0, 3), 1, map_texture_on_sphere, 
			color_expr(0, 0, 0) ); 
	sphere -> t = stripes; 
	object *sphere_small = sphere_obj(xyz_expr(0.5, -0.7, 2), 0.5, 
			map_texture_on_sphere, color_expr(0, 0, 0) ); 
	sphere_small -> t = make_waves(100, 0, 0, color_expr(1, 0, 0) ); 
	light l = {xyz_expr(-0.58, 0.58, -0.58), color_expr(1, 1, 1) };
	
	obj_list* objs = ol_singleton(*pst); 
	objs = ol_cons(*sphere, objs); 
	objs = ol_cons(*sphere_small, objs); 
	scene scn = { {0,0,0.25}, objs, l,
	   	color_expr(0.1, 0.1, 0.1) };
    free(pst);
    stage stg = {cam,scn};
    return stg;
  } 
  if (selection==100) {
    /* striped sphere */
    camera c = {{0,0,-5},1280,720};
    light l = { xyz_expr(-0.58, 0.58, -0.58), color_expr(1, 1, 1) }; 
    //texture* tex = make_vert_stripes(color_expr(0.5, 0.5, 0.8), color_expr(0.9, 0, 0), 7); 
    texture* tex = make_waves(600, 0, 0, color_expr(1.0, 0, 0) ); 
    object *sph = sphere_obj(xyz_expr(0,0,3),1,&map_texture_on_sphere,color_expr(0,0,0));
    sph -> t = tex;  
    scene s = {{0,0,0.25},NULL, l, color_expr(0.1, 0.1, 0.1) };
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==101) {
    /* let's get a better look at the striped sphere... */
    camera c = {{0,0,-5},500,800};
    object *sph = sphere_obj(xyz_expr(0,0,4),1,&sphere_horiz_stripes,color_expr(0,0,0));
    scene s = {{0,0,0.25},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==103) {
    /* based on gallery image 3 */
    camera c = {{0,0,-5},120,120};
    object *sph = sphere_obj(xyz_expr(1,0,4),1,&sc_red,color_expr(0,0,0));
    scene s = {{0,0,0.25},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==104) {
    /* based on gallery image 4 */
    camera c = {{0,0,-5},120,120};
    object *sph0 = sphere_obj(xyz_expr(0,0,3),1,&sc_blue,color_expr(0,0,0));
    object *sph1 = sphere_obj(xyz_expr(-0.5,0.7,3),0.5,&sc_red,color_expr(0,0,0));
    scene s = {{0,0,0.25},NULL};
    s.objects = ol_cons(*sph0,ol_singleton(*sph1));    
    free(sph0);
    free(sph1);
    stage g = {c,s};
    return g;
  }

  /* some simple examples for students */
  if (selection==15200) {
    camera c = {{0,0,-5},300,300};
    object *sph = sphere_obj(xyz_expr(0,0,3),1,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==15201) {
    camera c = {{0,0,-5},600,300};
    object *sph = sphere_obj(xyz_expr(0,0,3),1,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==15202) {
    camera c = {{0,0,-5},300,600};
    object *sph = sphere_obj(xyz_expr(0,0,3),1,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==15203) {
    camera c = {{0,0,-5},300,300};
    object *pst = poster_obj(xyz_expr(-1,1,3),1,1,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*pst);
    free(pst);
    stage g = {c,s};
    return g;
  } 
  if (selection==15204) {
    camera c = {{0,0,-5},300,300};
    object *pst = poster_obj(xyz_expr(-1,1,3),2,1,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*pst);
    free(pst);
    stage g = {c,s};
    return g;
  } 
  if (selection==15205) {
    camera c = {{0,0,-5},300,300};
    object *pst = poster_obj(xyz_expr(-1,1,3),1,2,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*pst);
    free(pst);
    stage g = {c,s};
    return g;
  } 
  if (selection==15206) {
    camera c = {{0,0,-5},200,400};
    object *sph0 = sphere_obj(xyz_expr(-1,0,3),0.3,&sc_blue,color_expr(0,0,0));
    object *sph1 = sphere_obj(xyz_expr(1,0,3),0.3,&sc_maroon,color_expr(0,0,0));    
    scene s = {{0,0,0},NULL};
    s.objects = ol_cons(*sph0,ol_singleton(*sph1));
    free(sph0);
    free(sph1);
    stage g = {c,s};
    return g;
  }
	fprintf(stderr,"error (get_stage): undefined selection %u\n"
                 "(see get_stage in stage.c for available selections)\n",selection);
	exit(1);
} 
#include <stdio.h> 
#include <stdlib.h> 
#include "raytracer.h"
#include <math.h>

/* =================================== */ 
/* === texture operations => texture.c === */ 
/* =================================== */ 

/* coloring functions specified on web page */

/* _dist : compute Euclidean distance in 3-space */
double _dist(xyz a, xyz b)
{
  double dx = a.x-b.x;
  double dy = a.y-b.y;
  double dz = a.z-b.z;
  return sqrt(dx*dx+dy*dy+dz*dz);
}

/* poster_red_distance - calculate distance from upper-left-corner, use to 
 * scale from black at upper-left to red at lower-right
 */
color poster_red_distance(object *o, location loc)
{
  if (o->tag!=POSTER) {
    fprintf(stderr,"error (poster_red_distance): not a poster\n");
    exit(1);
  }
  location ulc = o->o.p.upper_left;
  /* compute lower right corner */
  location lrc = {ulc.x+o->o.p.w,ulc.y+o->o.p.h,ulc.z}; 
  /* take the distance from between loc and ulc, and divide by total distance
   * from the ulc to rlc. place that result as the red in a color.
   */
  return color_expr(_dist(ulc,loc)/_dist(ulc,lrc),0,0);
}

/* poster_rgb_distance - calculate distance from upper-left-corner, use to 
 * scale from all red at upper-left to all blue at lower-left, with 
 * green in the middle, and gradations between them.
 */
color poster_rgb_distance(object *o, location loc)
{
  if (o->tag!=POSTER) {
    fprintf(stderr,"error (poster_rgb_distance): not a poster\n");
    exit(1);
  }
  location ulc = o->o.p.upper_left;
  /* compute lower right corner */
  location lrc = {ulc.x+o->o.p.w,ulc.y+o->o.p.h,ulc.z}; 
  /* relative ratio within poster */
  double ratio = _dist(ulc,loc)/_dist(ulc,lrc);
  /* for the first half, we blend from red to green */
  if (ratio<=0.5)
    return color_expr(1-ratio*2,ratio*2,0);
  /* for the first half, we blend from green to blue */
  else 
    return color_expr(0,2*(1-ratio),2*ratio-1);
}


/* sphere_loc_to_rgb - scale the location so that it maps x, y, z onto r, g, b in 
 * a way that shows gradations in the sphere. You are being given flexibility to 
 * do this in a way that looks interesting to you.
 */
/* Note: Yours does NOT need to be exactly like this - this is one solution */
color sphere_loc_to_rgb(object *o, location loc)
{
  // separately find relative x, y, z (relative to sphere),                                           
  // then map onto 0->1 or r, g, b                                                                    
  sphere *s = &(o->o.s);

  // 0 to 1 - where are x and y within poster?                                                        
  double x_within_sphere = (s->center.x+s->radius - loc.x)/
    (s->radius*2);
  double y_within_sphere = (s->center.y+s->radius - loc.y)/
    (s->radius*2);
  double z_within_sphere = (s->center.z+s->radius - loc.z)/
    (s->radius*2);

  return color_expr(x_within_sphere, y_within_sphere, z_within_sphere);

}


/* sphere_stripes - color the sphere with 4 blue stripes on a white background.
 * the pattern is: WBWBWBWBW. The stripes and background are roughly equal height.
 */
color sphere_horiz_stripes(object *o, location loc)
{
  if (o->tag!=SPHERE) {
    fprintf(stderr,"error (sphere_horiz_stripes): not a sphere\n");
    exit(1);
  }    
  location ctr = o->o.s.center;
  double rad = o->o.s.radius;
  double dy = loc.y-ctr.y;
  double s = (dy+rad)/(2*rad); /* s is on [0,1] */
  int n = (int)floor(s*9);     /* n is on [0,9] */
  if (n==9) n--;               /* n is on [0,8] */
  return n%2?color_expr(0,0,1):color_expr(1,1,1);
}


/* map_texture_on_sphere takes an object. Uses polar coordinates 
 * to scale on vertical (phi) on [-pi/2, pi/2] and horizontal (theta) 
 * on [-pi, pi]. Then scales to width and height of texture bitmap 
 * returns the color at location loc 
 */
color map_texture_on_sphere(object *o, location loc) { 
    double phi =  -asin(  (loc.y - o -> o.s.center.y) /  o -> o.s.radius ); 
    double theta = atan2( (loc.x - o -> o.s.center.x) / (o -> o.s.radius * cos(phi) ),
			 -(loc.z - o -> o.s.center.z) / (o -> o.s.radius * cos(phi) ) ); 

    int a = (0.5 + phi /        M_PI)   * o -> t -> height; 
    int b = (0.5 + theta / (2 * M_PI) ) * o -> t -> width; 

    if(a == o -> t -> height)
	a--; 
    if(b == o -> t -> width) 
	b--; 
    
    return o -> t -> pixels[a][b]; 
} 

/* map_texture_on_poster takes an object (which is assumed to have
 * tag == POSTER) and an intersection point. It uses the bitmap contained
 * in the object, the attributes of the poster, and the intersection
 * point to determine the color at that intersection point. It scales the 
 * height and width, stretching or shrinking the bitmap to match the 
 * poster.
 */
color map_texture_on_poster(object *o, location loc) { 

    int a = ( fabs(loc.y - o -> o.p.upper_left.y) ) * o -> t -> height / o -> o.p.h; 
    int b = ( fabs(loc.x - o -> o.p.upper_left.x) ) * o -> t -> width  / o -> o.p.w; 

    if(a == o -> t -> height) 
	a--; 
    if(b == o -> t -> width) 
	b--;
    return o -> t -> pixels[a][b]; 
} 


/* general function for making texture */ 
texture* make_texture(color c1, color c2, int N, int M){
    color** pixel = malloc( N * sizeof(*pixel) );
    for (int i = 0; i < N; i++){
	pixel[i] = malloc( M * sizeof(color) );
	for (int j = 0; j < M; j++)
	    pixel[i][j] = (i ^ j) & 1 ? c2 : c1;
    }

    texture* t = malloc( sizeof(*t) );
    t -> height = N;
    t -> width  = M;
    t -> pixels = pixel;
    return t;
}

/* makes horizontal stripes texture */ 
texture *make_horiz_stripes(color c1, color c2, int num_stripes) { 
    return make_texture(c1, c2, num_stripes, 1);
} 

/* makes vertical stripes texture */ 
texture *make_vert_stripes(color c1, color c2, int num_stripes) { 
    return make_texture(c1, c2, 1, num_stripes); 
} 


/* Returns the distance between (x0, y0) and (x1, y1) */
double _dist_points(double x0, double y0, double x1, double y1) {

    double x = x1 - x0;
    double y = y1 - y0;

    return sqrt(x * x + y * y);
}


/* helper for waves, gives color at certain point */ 
color _wave_color(int x, int y, int xc, int yc, color c) { 

    double sin_res = sin( _dist_points(x, y, xc, yc) );
    double col_b = (sin_res + 1) / 2;
    return color_scale(col_b, c); 
}  

/* makes wave type texture */ 
texture *make_waves(int length, int x_offset, int y_offset, color col) { 

    texture *t = malloc(sizeof(texture) ); 
    t -> width = length; 
    t -> height = length; 

    int xc = length / 2; 
    int yc = length / 2; 
    if(length & 1) {
	xc += x_offset; 
	yc += y_offset; 
    } 
    
    color** pixels_table = malloc(sizeof(color) * length * length); 
    for(int i = 0; i < length; ++i) { 
	pixels_table[i] = malloc(sizeof(color) * length); 
	for(int j = 0; j < length; ++j) { 
	    pixels_table[i][j] = _wave_color(j, i, xc, yc, col);
	} 
    } 
    t -> pixels = pixels_table; 
    return t; 
} 





#include <string.h>
#include <math.h>
#include "raytracer.h"

/* ================================== */ 
/* === vector operations => xyz.c === */ 
/* ================================== */ 

xyz xyz_expr(double x, double y, double z)
{
  xyz v = {x,y,z};
  return v;
}

/* xyz_add : add two vectors */
/* (x,y,z) + (X,Y,Z) = (x+X,y+Y,z+Z) */
xyz xyz_add(xyz v1, xyz v2) 
{
  return xyz_expr(v1.x+v2.x,v1.y+v2.y,v1.z+v2.z);
}

/* xyz_sub : subtract the second vector from the first */
/* (x,y,z) - (X,Y,Z) = (x-X,y-Y,z-Z) */
xyz xyz_sub(xyz v1, xyz v2)
{
  return xyz_expr(v1.x-v2.x,v1.y-v2.y,v1.z-v2.z);
}

/* xyz_neg : negate a vector */
/* -(x,y,z) = (-x,-y,-z) */
xyz xyz_neg(xyz v)
{
  return xyz_expr(-v.x,-v.y,-v.z);
}

/* xyz_scale : scale the components of a vector by scalar s */
/* s(x,y,z) = (sx,sy,sz) */
xyz xyz_scale(double s, xyz v)
{
  return xyz_expr(s*v.x,s*v.y,s*v.z);
}

/* xyz_dot : compute the dot product of two vectors */
/* (x,y,z) dot (X,Y,Z) = xX+yY+zZ */
double xyz_dot(xyz v1, xyz v2)
{
  return v1.x*v2.x+v1.y*v2.y+v1.z*v2.z;
}

/* xyz_mag : compute the magnitude of a vector */
/* the square root of the sum of the squares of the components */
double xyz_mag(xyz v)
{
  return sqrt(v.x*v.x+v.y*v.y+v.z*v.z);
}

/* xyz_norm : normalize the vector */
/* i.e., a vector pointing in the same direction whose magnitude is 1 */
/* - normalize a vector by scaling by 1 over its magnitude */
/* - if a vector's magnitude is zero, it can't be normalized; return it */
xyz xyz_norm(xyz v)
{
  double m = xyz_mag(v);
  return m==0 ? v : xyz_scale(1.0/m,v);
}

const char *_xyz_fmt = "xyz(%lf,%lf,%lf)";

char *xyz_tos(xyz v)
{
  char buf[128];
  memset(buf,0,128);
  snprintf(buf,128,_xyz_fmt,v.x,v.y,v.z);
  return strdup(buf);
}

void xyz_show(FILE *f, xyz v)
{
  fprintf(f,_xyz_fmt,v.x,v.y,v.z);
}

#ifndef __RAYTRACER_H__
#define __RAYTRACER_H__

/* raytracer.h
 * CS152 Winter 2015
 * Project B
 * Feb 2015
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>

/* ====================================== */ 
/* ====================================== */ 
/* === STRUCTURE AND TYPE DEFINITIONS === */ 
/* ====================================== */ 
/* ====================================== */ 

typedef unsigned char byte;

typedef struct {
  double x;
  double y;
  double z;
} xyz;

/* Note: Because xyz can be used for both a particular location
 * and a directional vector, we can use the same struct and 
 * typedef for clarity. We may use the three names interchangeably.
 * This allows us to share the basic operations (add, sub, mag, scale).
 * We are not required to use location and direction, it is merely a 
 * tool to help us understand what our (or someone else's) code is doing.
 */

typedef xyz location;
typedef xyz direction;

typedef struct {
  /* each value must be on interval [0,1] */
  double r;
  double g;
  double b;
} color;

typedef struct {
  location origin;
  direction dir;
} ray;

typedef struct _object object;

typedef struct {
  location center;
  double radius;
  color(*surface_color)(object *o, location loc);
  color shine;
  object *o; // optional - you decide whether to use it
} sphere;

typedef struct {
  xyz upper_left;
  double w;
  double h;
  color(*surface_color)(object *poster, location intersection);
  color shine;
  object *o; // optional - you decide whether to use it
} poster;

union object_union {
  sphere s;
  poster p;
};

typedef struct {
        color **pixels;
        int height;
        int width;
} texture;

struct _object{
  enum  { SPHERE, POSTER } tag;
  union object_union o;
  texture *t;
};

typedef struct obj_list obj_list;
/* convention: NULL is the empty object list */
struct obj_list {
  object obj;
  obj_list *next;
};

typedef struct {
  direction dir; /* note: the vector points AT the light */
  color c;
} light;

typedef struct {
  color bg;
  obj_list *objects;
  light light;
  color amb;
} scene;

typedef struct {
  enum {MISS=0,HIT=1} miss;
  double t;
  location hit_point;
  color surf; 
  color shine; // not used in project B
  direction surf_norm;
} hit_test;

typedef struct {
  location loc;
  unsigned int h;
  unsigned int w;
} camera;

typedef struct {
  camera c;
  scene s;
} stage;

/* ================== */ 
/* ================== */ 
/* === OPERATIONS === */ 
/* ================== */ 
/* ================== */ 

/* Please note: the following is not necessarily every operation you
 * will need, nor will you necessarily use every operation in your
 * implementation.  Add and implement additional operations as you
 * require them.
 */

/* ================================== */ 
/* === vector operations => xyz.c === */ 
/* ================================== */ 

xyz xyz_expr(double x, double y, double z);

/* xyz_add : add two vectors */
/* (x,y,z) + (X,Y,Z) = (x+X,y+Y,z+Z) */
xyz xyz_add(xyz v1, xyz v2);

/* xyz_sub : subtract the second vector from the first */
/* (x,y,z) - (X,Y,Z) = (x-X,y-Y,z-Z) */
xyz xyz_sub(xyz v1, xyz v2);

/* xyz_neg : negate a vector */
/* -(x,y,z) = (-x,-y,-z) */
xyz xyz_neg(xyz v);

/* xyz_scale : scale the components of a vector by scalar s */
/* s(x,y,z) = (sx,sy,sz) */
xyz xyz_scale(double s, xyz v);

/* xyz_dot : compute the dot product of two vectors */
/* (x,y,z) dot (X,Y,Z) = xX+yY+zZ */
double xyz_dot(xyz v1, xyz v2);

/* xyz_mag : compute the magnitude of a vector */
/* the square root of the sum of the squares of the components */
double xyz_mag(xyz v);

/* xyz_norm : normalize the vector */
/* i.e., a vector pointing in the same direction whose magnitude is 1 */
/* - normalize a vector by scaling by 1 over its magnitude */
/* - if a vector's magnitude is zero, it can't be normalized; return it */
xyz xyz_norm(xyz v);

char *xyz_tos(xyz v);

void xyz_show(FILE *f, xyz v);

/* =============================== */ 
/* === color operations => color.c === */ 
/* =============================== */ 

/* reject if any component is outside [0.0,1.0] */
color color_expr(double r, double g, double b);

/* color_modulate : multiply the components or two colors */
/* (r,g,b) * (R,G,B) = (rR,gG,bB) */
color color_modulate(color c1, color c2);

/* color_scale : scale each component by given scalar, but */
/* don't allow any component in the result to fall outside [0,1] */
color color_scale(double s, color c);

/* add components of colors, but */
/* don't allow any component in the result to exceed 1 */
color color_add(color c1, color c2);

char *color_tos(color c);

void color_show(FILE *f, color c);

/* color_show_bytes */
/* print three integers on [0,255] with spaces in between and a newline */
/* suitable for use in a PPM */
void color_show_bytes(FILE *f, color c);

/* =============================== */ 
/* === ray operations => ray.c === */ 
/* =============================== */ 

/* see web page for ray_position code */
xyz ray_position(ray r, double t);

char *ray_tos(ray r);

void ray_show(FILE *f, ray r);

/* ===================================== */ 
/* === sphere operations => sphere.c === */ 
/* ===================================== */ 

sphere sphere_expr(location v, double r, color(*sc)(object *,location), color sh);

char *sphere_tos(sphere s);

void sphere_show(FILE *f, sphere s);

/* ===================================== */ 
/* === slab operations => poster.c ===== */ 
/* ===================================== */ 

poster poster_expr(location ulc, double w, double h, 
		   color(*sc)(object*,location), color sh);

char *poster_tos(poster s);

void poster_show(FILE *f, poster s);

/* ===================================== */ 
/* === object operations => object.c === */ 
/* ===================================== */ 

char *object_tos(object o);

void object_show(FILE *f, object o);

/* ======================================== */ 
/* === object list ops => obj_list.c ====== */ 
/* ======================================== */ 

obj_list *ol_cons(object o, obj_list *os);

obj_list *ol_singleton(object s);

char *ol_tos(obj_list *os);

void ol_show(FILE *f, obj_list *os);

void ol_free(obj_list *ss);

/* =================================== */ 
/* === light operations => light.c === */ 
/* =================================== */ 

char *light_tos(light l);

void light_show(FILE *f, light l);

/* =================================== */ 
/* === scene operations => scene.c === */ 
/* =================================== */ 

char *scene_tos(scene sc);

void scene_show(FILE *f, scene sc);

/* ========================================= */ 
/* === hit_test operations => hit_test.c === */ 
/* ========================================= */ 

char *hit_test_tos(hit_test t);

void hit_test_show(FILE *f, hit_test t);

/* ===================================== */ 
/* === camera operations => camera.c === */ 
/* ===================================== */ 

char *camera_tos(camera cm);

void camera_show(FILE *f, camera cm);

/* =================================== */ 
/* === stage operations => stage.c === */ 
/* =================================== */ 

char *stage_tos(stage stg);

void stage_show(FILE *f, stage stg);

/* The function get_stage just needs to return a valid stage. */
/* The argument may be used, or not, at your discretion. */
stage get_stage(unsigned int selection);

/* ================================================ */ 
/* ================================================ */ 
/* === RAY TRACER LOGIC and MAIN => raytracer.c === */ 
/* ================================================ */ 
/* ================================================ */ 

/* === project 1 operations === */

/* === intersect.c === */

hit_test intersect(ray r, object obj);

/* === raytracer.c === */

/* Functions from project A */
location logical_loc(camera c, unsigned int x, unsigned int y);
color trace_ray(scene s, ray r);
void render(FILE *f, stage g);

/* Functions from project B */

/* Given an intersection location p, light source, and object list,
 * check each object to see if it intersects the shadow ray. 
 * return nonzero if the location p is in shadow. Return 0 if not.
 */
int shadow(location p, light l, obj_list *objs);

/* Given a scene, ray, and hit_test, determine the color of the pixel.
 * The hit_test already calculated the surface color of the shape in the 
 * absence of lighting. Here, you take into account shadow and ambient
 * light to adjust the color. */
color lighting(scene s, ray r, hit_test h);

/* === rt.c === */

int main(int argc, char *argv[]);

/* === tracer.c === */
/* Functions from project A that you already implemented */

/* poster_red_distance - calculate distance from upper-left-corner, use to 
 * scale from black at upper-left to red at lower-right
 */
color poster_red_distance(object *o, location loc); 
/* poster_rgb_distance: calculate distance from upper-left-corner, use to 
 * scale from all red at upper-left to all blue at lower-right, with 
 * green in the middle, and gradations between them.
 */
color poster_rgb_distance(object *o, location loc); 
/* sphere_loc_to_rgb: scale the location so that it maps x, y, z onto r, g, b 
 * in a way that shows gradations in the sphere. 
 */
color sphere_loc_to_rgb(object *o, location loc); 
/* sphere_stripes: color the sphere with 4 blue stripes on a white background.*/
color sphere_horiz_stripes(object *o, location loc); 

/* Functions in project B that you are supposed to implement  - see
 * assignment description for details on each function. */

/* map_texture_on_sphere takes an object (which is assumed to have
 * tag == SPHERE) and an intersection point. It uses the bitmap contained
 * in the object, the attributes of the sphere, and the intersection
 * point to determine the color at that intersection point.
 * It uses the circumference of a horizontal circle drawn on the 
 * sphere at that point to determine the width for stretching purposes.
 * The first gallery pictures show the the stripes get stretched to be 
 *  wider in the middle of the ball and narrower at the top and bottom.
 */
color map_texture_on_sphere(object *o, location intersection);

/* map_texture_on_poster takes an object (which is assumed to have
 * tag == POSTER) and an intersection point. It uses the bitmap contained
 * in the object, the attributes of the sphere, and the intersection
 * point to determine the color at that intersection point. It scales the 
 * height and width, stretching or shrinking the bitmap to match the 
 * poster.
 */
color map_texture_on_poster(object *o, location intersection);

/* maes horizontal stripes texeure */ 
texture *make_texture(color c1, color c2, int N, int M); 

texture *make_horiz_stripes(color c1, color c2, int num_stripes);

/* makes vertical stripes texture */ 
texture *make_vert_stripes(color c1, color c2, int num_stripes);

/* makes wave type texture */ 
texture *make_waves(int length, int x_offset, int y_offset, color col);


#endif /* __RAYTRACER_H__ */

